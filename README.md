# async-qps-throttle

This package provides throttling of promise-based work, based on one or both of QPS (queries per second)
and the amount of concurrent active work. ES6 or higher is required.

## Use

### Creation

Simply import `AsyncThrottle` from this package:

```
import {AsyncThrottle} from 'async-qps-throttle';

const throttle = new AsyncThrottle({maxQps: 10, maxOutstanding: 10});
```

The constructor takes an options object hash. The available options are:
  * `maxQps`: The maximum number of work items that will be *started* in any given second using a rolling
     window (note that work may continue to run and won't count against QPS)
  * `maxOutstanding`: The maximum number of work items that may be actively running at any given time

The example above creates a throttle that will ensure that no more than 10 work items are executed in any
given period of one second, and no more than 10 work items are ever concurrently running.

### Providing Work

Work is provided in the form of a function which takes no parameters and returns a promise (the implementation
uses the native ES6 `Promise`, see below for more information). The use of a generator function allows the
throttle to determine the appropriate time to actually start the work. Work is provided to the single method
`callThrottled`, like so:

```
...

// Pre-defined function.
function postToSite() {
  return xhrPromise.send({...});
}
throttle.callThrottled(postToSite);

// Arrow function.
throttle.callThrottled(() => xhrPromise.send({...}));

...
```

### Where's My Promise?

`callThrottled` returns a promise that is immediately available and will eventually settle in the same way as the
promise generated by the work function. If the work function throws, this promise will also be rejected with that error.

```
...

// Unthrottled call.
const unthrottledPromise = xhrPromise.send({...});

// Throttled call.
const throttledPromise = throttle.callThrottled(() => xhrPromise.send({...}));

// Inline then-ing with throttle.
throttle
  .callThrottled(() => xhrPromise.send({...}))
  .then(response => {...});
  
...
```

### When Is Everything Done?

`AsyncThrottle` provides two additional methods for figuring out when all work is complete (aside from just keeping
and waiting on the returned promises). The first is `whenDrained`, a method that provides a promise that will resolve
at the next moment when all tracked work is complete. This promise does not provide any results, but simply acts as
a way to ensure work has completed. This promise is never rejected.

```
...

throttle.callThrottled(() => xhrPromise.send({...}));
throttle.callThrottled(() => xhrPromise.send({...}));
throttle.callThrottled(() => xhrPromise.send({...}));
throttle.callThrottled(() => xhrPromise.send({...}));
throttle
  .whenDrained()
  .then(() => {...});

...
```

The second is a static method called `callAllThrottled`, which works similarly to `Promise.all` but will throttle the
array of work items according to throttling options provided with the call.

```
...

const workFn1 = () => return Promise.resolve(1);
const workFn2 = () => return Promise.resolve(2);
const workFn3 = () => return Promise.resolve(3);

AsyncThrottle
  .callAllThrottled([workFn1, workFn2, workFn3], {maxQps: 1})
  .then(result => {... result will be [1, 2, 3] ...});

...
```

The promise returned by `callAllThrottled` will be resolved with an array of results that correspond to the input work,
or will be rejected with the first error that any executed work returned.

## Details

To come.
